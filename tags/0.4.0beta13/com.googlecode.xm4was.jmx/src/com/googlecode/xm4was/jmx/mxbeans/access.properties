ClassLoading.getLoadedClassCount=monitor
ClassLoading.getTotalLoadedClassCount=monitor
ClassLoading.getUnloadedClassCount=monitor
ClassLoading.isVerbose=monitor
# setVerbose requires ManagementPermission("control")
ClassLoading.setVerbose=operator
Compilation.getName=monitor
Compilation.getTotalCompilationTime=monitor
Compilation.isCompilationTimeMonitoringSupported=monitor
GarbageCollector.getLastCollectionStartTime=monitor
GarbageCollector.getLastCollectionEndTime=monitor
GarbageCollector.getMemoryUsed=monitor
GarbageCollector.getTotalMemoryFreed=monitor
GarbageCollector.getTotalCompacts=monitor
GarbageCollector.getCollectionCount=monitor
GarbageCollector.getCollectionTime=monitor
GarbageCollector.getMemoryPoolNames=monitor
GarbageCollector.getName=monitor
GarbageCollector.isValid=monitor
MemoryManager.getMemoryPoolNames=monitor
MemoryManager.getName=monitor
MemoryManager.isValid=monitor
Memory.getMaxHeapSizeLimit=monitor
Memory.getMaxHeapSize=monitor
Memory.getMinHeapSize=monitor
# Changing values should be limited to the operator role
Memory.setMaxHeapSize=operator
Memory.isSetMaxHeapSizeSupported=monitor
Memory.getSharedClassCacheSize=monitor
Memory.getSharedClassCacheFreeSpace=monitor
Memory.getGCMode=monitor
# Triggering garbage collections has an impact on performance; require operator role
Memory.gc=operator
Memory.getHeapMemoryUsage=monitor
Memory.getNonHeapMemoryUsage=monitor
Memory.getObjectPendingFinalizationCount=monitor
Memory.isVerbose=monitor
# setVerbose requires ManagementPermission("control")
Memory.setVerbose=operator
MemoryPool.getPreCollectionUsage=monitor
MemoryPool.getCollectionUsage=monitor
MemoryPool.getCollectionUsageThreshold=monitor
MemoryPool.getCollectionUsageThresholdCount=monitor
MemoryPool.getMemoryManagerNames=monitor
MemoryPool.getName=monitor
MemoryPool.getPeakUsage=monitor
MemoryPool.getType=monitor
MemoryPool.getUsage=monitor
MemoryPool.getUsageThreshold=monitor
MemoryPool.getUsageThresholdCount=monitor
MemoryPool.isCollectionUsageThresholdExceeded=monitor
MemoryPool.isCollectionUsageThresholdSupported=monitor
MemoryPool.isUsageThresholdExceeded=monitor
MemoryPool.isUsageThresholdSupported=monitor
MemoryPool.isValid=monitor
# resetPeakUsage requires ManagementPermission("control")
MemoryPool.resetPeakUsage=operator
# setCollectionUsageThreshold requires ManagementPermission("control")
MemoryPool.setCollectionUsageThreshold=monitor
# setUsageThreshold requires ManagementPermission("control")
MemoryPool.setUsageThreshold=monitor
OperatingSystem.getTotalPhysicalMemory=monitor
OperatingSystem.getProcessingCapacity=monitor
OperatingSystem.getProcessCpuTime=monitor
OperatingSystem.getProcessCpuTimeByNS=monitor
OperatingSystem.getSystemCpuLoad=monitor
OperatingSystem.getFreePhysicalMemorySize=monitor
OperatingSystem.getProcessVirtualMemorySize=monitor
OperatingSystem.getProcessPrivateMemorySize=monitor
OperatingSystem.getProcessPhysicalMemorySize=monitor
OperatingSystem.getTotalSwapSpaceSize=monitor
OperatingSystem.getFreeSwapSpaceSize=monitor
OperatingSystem.getProcessCpuLoad=monitor
OperatingSystem.getArch=monitor
OperatingSystem.getAvailableProcessors=monitor
OperatingSystem.getName=monitor
OperatingSystem.getVersion=monitor
OperatingSystem.getSystemLoadAverage=monitor
# getBootClassPath requires ManagementPermission("monitor")
Runtime.getBootClassPath=monitor
Runtime.getClassPath=monitor
# getInputArguments requires ManagementPermission("monitor")
# VisualVM 1.3.2 will fail if it doesn't have access to the JVM arguments
Runtime.getInputArguments=monitor
Runtime.getLibraryPath=monitor
Runtime.getManagementSpecVersion=monitor
Runtime.getName=monitor
Runtime.getSpecName=monitor
Runtime.getSpecVendor=monitor
Runtime.getSpecVersion=monitor
Runtime.getStartTime=monitor
Runtime.getSystemProperties=monitor
Runtime.getUptime=monitor
Runtime.getVmName=monitor
Runtime.getVmVendor=monitor
Runtime.getVmVersion=monitor
Runtime.isBootClassPathSupported=monitor
# findMonitorDeadlockedThreads requires ManagementPermission("monitor")
Threading.findMonitorDeadlockedThreads=operator
# getAllThreadIds requires ManagementPermission("monitor")
Threading.getAllThreadIds=operator
Threading.getCurrentThreadCpuTime=monitor
Threading.getCurrentThreadUserTime=monitor
Threading.getDaemonThreadCount=monitor
Threading.getPeakThreadCount=monitor
Threading.getThreadCount=monitor
Threading.getThreadCpuTime=monitor
# getThreadInfo requires ManagementPermission("monitor")
Threading.getThreadInfo=operator
Threading.getThreadUserTime=monitor
Threading.getTotalStartedThreadCount=monitor
Threading.isCurrentThreadCpuTimeSupported=monitor
Threading.isThreadContentionMonitoringEnabled=monitor
Threading.isThreadContentionMonitoringSupported=monitor
Threading.isThreadCpuTimeEnabled=monitor
Threading.isThreadCpuTimeSupported=monitor
# resetPeakThreadCount requires ManagementPermission("control")
Threading.resetPeakThreadCount=operator
# setThreadContentionMonitoringEnabled requires ManagementPermission("control")
Threading.setThreadContentionMonitoringEnabled=operator
# setThreadCpuTimeEnabled requires ManagementPermission("control")
Threading.setThreadCpuTimeEnabled=operator
Threading.isObjectMonitorUsageSupported=monitor
Threading.isSynchronizerUsageSupported=monitor
# findDeadlockedThreads requires ManagementPermission("monitor")
Threading.findDeadlockedThreads=operator
# dumpAllThreads requires ManagementPermission("monitor")
Threading.dumpAllThreads=operator
